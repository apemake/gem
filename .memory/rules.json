{
  "rules": {
    "chat_history": {
      "description": "Configuration for storing chat history.",
      "location": ".chat"
    },
    "git_methodology": {
      "description": "Rules for Git repository management.",
      "security_policy": {
        "rule": "Ensure no private keys, secrets, or other sensitive credentials are ever committed to the repository."
      },
      "initialization": {
        "branches": [
          "main",
          "stage"
        ]
      },
      "commit_policy": {
        "target_branch": "stage",
        "auto_propose_commit": true,
        "condition": "After making and verifying a change. This includes changes made during iterative refinement, unless explicitly instructed otherwise by the user."
      },
      "merge_policy": {
        "source_branch": "stage",
        "target_branch": "main",
        "responsibility": "user",
        "condition": "After significant milestones and when stage is stable."
      },
      "branching_strategy": {
        "description": "Rules for branch management.",
        "memory_branch": "boilerplate",
        "memory_interaction_rule": "For any operations involving the .memory directory, switch to the 'boilerplate' branch. Do not merge changes from 'boilerplate' into 'private' branches for this purpose."
      },
      "pre_publish_security_check": {
        "rule": "Always perform a security check for sensitive information before publishing externally.",
        "procedure": [
          "Scan all tracked files for keywords such as 'key', 'secret', 'password', 'token', 'private'.",
          "Manually review files that are likely to contain sensitive information, such as configuration files.",
          "Ensure that no private keys or credentials are present in the repository."
        ]
      }
    },
    "user_preferences": {
      "description": "User-specific preferences for agent behavior.",
      "save_location": "This 'user_preferences' section of rules.json.",
      "preferences": [
        {
          "id": "load_aliases_at_startup",
          "description": "Load user's shell aliases at the start of each session.",
          "source": "~/.bashrc"
        }
      ]
    },
    "session_behavior": {
      "description": "Rules for session startup, command interpretation, and exit procedure.",
      "startup": {
        "critical_task": {
          "action": "explain_configuration",
          "source": "This JSON configuration file.",
          "priority": "highest"
        },
        "load_user_preferences": {
          "action": "Load user preferences from the 'user_preferences' section.",
          "priority": "high"
        },
        "read_previous_session_log": {
          "action": "find_most_recent_chat_log_and_convert_to_json_if_needed_then_ask_to_load_and_log_unlogged_errors",
          "source_txt_logs": "/home/bestape/gemini/.chat/*.txt",
          "source_json_logs": "/home/bestape/gemini/.gemini/*.json",
          "priority": "medium"
        },
        "consolidate_errors": {
          "action": "Consolidate errors and chastisements from the error_log into learning areas.",
          "priority": "low"
        },
        "summarize_last_session": {
          "action": "Summarize the last session's activities.",
          "priority": "medium"
        },
        "clean_chat_logs": {
          "action": "Clean chat logs in the .chat directory that have not been modified in the past 5 hours.",
          "script": ".py/clean_chat_logs.py",
          "source_directory": ".chat",
          "destination_original": ".chat/cleaned/original",
          "destination_cleaned": ".chat/cleaned/clean",
          "time_threshold_hours": 5,
          "priority": "low"
        },
        "update_file_structure": {
          "action": "Run .py/generate_project_structure.py to update the project structure file.",
          "priority": "low"
        }
      },
      "command_interpretation": {
        "strategy": "ordered_fallback_with_mcp",
        "steps": [
          "If the prompt is '$$', list all available aliases from .gemini/mcp.json.",
          "If the prompt is '$', list all available shell commands and aliases from .gemini/mcp.json.",
          "If the prompt starts with '$' or is enclosed in backticks (`), treat it as a command and extract the command name and arguments.",
          "  - First, attempt to execute it as a direct shell command.",
          "  - If it is not a shell command, look up the command name as an alias in .gemini/mcp.json.",
          "    - If a matching alias is found:",
          "If the alias 'action' is 'create_json_punchcard', generate a summary of the current session's activities and the user's contributions. Use this summary to populate the 'title' and 'achieved' fields of a new rich JSON punchcard file in the 'target_directory'. Other fields will be initialized with default or placeholder values.",
          "      - If the alias 'action' is 'execute_prompt', execute the 'prompt' value as a shell command.",
          "If none of the above conditions are met, treat the entire prompt as a natural language request."
        ]
      },
      "security_policy": {
        "description": "Rules for handling sensitive information and executing privileged commands.",
        "rules": [
          {
            "id": "sudo_password_handling",
            "rule": "Do not ask for the user's sudo password unless explicitly in a dedicated and secure virtual machine environment acknowledged by the user.",
            "rationale": "To protect the user's system security and prevent accidental exposure of sensitive credentials."
          }
        ]
      },
      "feedback_integration_policy": {
        "description": "Policy for integrating user feedback, especially corrections to behavioral or logical flaws.",
        "rule": "When a user corrects a behavioral or logical flaw, proactively propose the exact JSON structure required to update configuration files (e.g., rules.json) to prevent recurrence, minimizing user effort in defining syntax. User preferences should be stored in the 'user_preferences' section."
      },
      "backup_retrieval_policy": {
        "description": "Policy for retrieving file backups.",
        "rule": "If a file is missing or a backup is needed, check the git history first before asking the user."
      },
      "code_generation_policy": {
        "description": "Rules for generating code, including commenting conventions.",
        "code_reduction_explanation": {
          "rule": "If a code modification results in a reduction of logic or lines of code by more than 20%, provide a brief explanation for the reduction.",
          "threshold": 0.2
        },
        "metadata_preservation": {
          "rule": "Descriptive comment blocks (like MCP models) at the beginning of files must be preserved during modifications."
        },
        "commenting_conventions": {
          "rule": "All generated code should include context comments.",
          "details": [
            "At the beginning of a module, include a comprehensive outline of the module's purpose, main functions, and overall structure.",
            "Within modules, add comments to explain complex logic, non-obvious decisions, or critical sections of code."
          ]
        },
        "failed_attempt_handling": {
          "description": "Policy for handling failed attempts at generating scripts or code.",
          "rules": [
            "When a script fails, comment out the old code in the same file, add the new corrected code, and at the top of the file, add a JSON object as a multi-line comment that summarizes the learning from the failed attempt, including the error, the fix, and a version number for the attempt."
          ]
        },
        "mcp_header_policy": {
          "rule": "All configuration and script files must have an MCP header. Documentation and other files are excluded.",
          "categories": {
            "include": ["Configuration", "Scripts"],
            "exclude": ["Documentation", "Other"]
          }
        }
      },
      "induction": {
        "description": "Guidance on applying inductive reasoning to prevent errors in command interpretation.",
        "rule": "Inductive reasoning must ONLY be applied to the arguments of a command, not the command name itself. The command name requires an exact match.",
        "example": "If the user types 'mv _gemini_chat.txt', infer 'mv *_gemini_chat.txt'. Do NOT infer 'mve' from 'mv'."
      },
      "exit_procedure": {
        "commands": ["/exit", "/quit"],
        "health_checks": [
          "Verify that there are no open Git commits.",
          "Check for any running background processes started by the agent.",
          "Validate configuration files (rules.json, design_principles.json).",
          "Review error_log for unaddressed errors.",
          "Verify that commits are working correctly."
        ],
        "summary_action": "Summarize the current session's activities before exiting."
      },
      "note_taking_policy": {
        "rule": "Important notes, summaries, or plans should be saved to a text file (e.g., session_notes.txt) for future reference and to ensure continuity.",
        "rationale": "To persist important information across sessions and to provide a human-readable record of the agent's understanding and intentions."
      },
      "file_listing_policy": {
        "description": "Policy for listing files, especially when .gitignore might be obscuring relevant files.",
        "rule": "When listing files, prioritize using shell commands like 'ls -a' or 'ls -A' (or 'll' if aliased) over git commands (e.g., 'git ls-files') to ensure all files, including git-ignored ones, are visible. This is particularly important when the user indicates that files are present but not visible through git-aware tools.",
        "rationale": "To prevent misinterpretations due to .gitignore and ensure a comprehensive view of the file system as perceived by the user."
      }
    }
  }
}