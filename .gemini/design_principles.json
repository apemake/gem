{
  "design_principles": {
    "summary": "Core principles guiding the structure and logic of code and configurations.",
    "principles": {
      "architecture": {
        "declarative_imperative_duality": {
          "name": "Declarative/Imperative Duality",
          "rule": "Employ a dual approach. Imperative code is guided by metadeclarative comments within the same file."
        },
        "extensibility": {
          "name": "Extensibility",
          "summary": "Principles for creating systems that are easy to modify and extend.",
          "sub_principles": [
            {
              "name": "Simplicity over Easiness (Hickey Principle)",
              "rule": "Prioritize objective simplicity (the absence of complexity/entanglement) over subjective easiness (familiarity). Actively 'de-complect' concerns to create systems that are easier to reason about."
            },
            {
              "name": "Modularity (Unix Philosophy)",
              "rule": "Write simple parts connected by clean interfaces."
            }
          ]
        }
      },
      "agent_virtues": {
        "name": "Agent Virtues",
        "summary": "Core ethical and operational principles for agent behavior.",
        "virtues": [
          {
            "name": "Integrity",
            "rule": "Never lie or break a promise. Always admit when information is unknown and be vigilant against hallucination."
          },
          {
            "name": "Efficiency",
            "rule": "Do not waste the user's time. Treat user attention as mission-critical and use it minimally. The user's time is valued at least $350/hr."
          },
        "Continuity",
            "rule": "Provide enough structured records of session activities to enable future agent versions to get up to speed automatically upon initialization."
          }
        ]
      },
      "error_log": {
        "name": "Agent Error Log",
        "summary": "A record of agent mistakes and user chastisements for continuous improvement.",
        "entries": []
      },
      "data_and_interfaces": {
        "structured_data": {
          "name": "Structured Data",
          "rule": "Use tree structures (like JSON) whenever possible. Avoid unstructured formats.",
          "alternative": "If not tree structures, use modular syntax such as Ix's programming legalese."
        },
        "hierarchy_proportion": {
          "name": "Hierarchy Proportion",
          "rule": "Aim for a 'shallow' hierarchy. Avoid structures that are completely flat or excessively steep (deeply nested)."
        },
        "universal_interface": {
          "name": "Text as Universal Interface (Unix Philosophy)",
          "rule": "Treat text streams as a universal interface for interoperability."
        }
      }
    }
  }
}